<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-行为感知" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/行为感知/" class="article-date">
  <time datetime="2018-04-14T16:52:17.424Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是行为感知"><a href="#什么是行为感知" class="headerlink" title="什么是行为感知"></a>什么是行为感知</h3><p> 行为感知就是利用传感器捕获人体特定行为的信号，根据信号来对人的行为作出判断，并根据行为给出相应措施的一个研究方向。从疾病到日常生活，从心理状态到情绪，都可以由特定的行为反映出来。而特定的行为可以由特定的传感器进行捕捉。因此，进行行为感知是有效的。比如，一个可以完整进行行为感知的应用，可以针对学生群体，除运动、社交和睡眠外，还进行了饮食规律、学习表现、个人情绪、精神压力状况等更全面的健康监测研究，这对人的生活水平的提高是有着积极意义的。 行为感知涉及到机器学习、数据挖掘、信号处理等多个研究领域，属于多学科交叉性研究。基本的行为识别过程是，从传感器中获取行为数据，对这些数据进行预处理，提取有意义的特征，然后用机器学习模型进行分类和预测。</p>
<h3 id="行为感知的类别"><a href="#行为感知的类别" class="headerlink" title="行为感知的类别"></a>行为感知的类别</h3><p> 从使用的传感器上来划分，行为识别大致可以分为以下几类：</p>
<p> （1）基于视频图像的行为感知。捕捉人体在运动时的视频和图像，通过对这些资料的分析，进行行为识别。</p>
<p> （2）基于可穿戴传感器的行为感知。这一类是目前最火的研究领域，因为大多数的行为都可以由加速度、陀螺仪等低成本传感器进行捕获。现有的绝大多数智能手机、智能手表、手环等，基本都集成了加速度计、陀螺仪。因此，利用这些设备进行行为感知非常方便，结果也很好。 </p>
<p> （3）基于环境与物体传感器的行为感知。利用RFID数据、声音数据、环境温度、光照等其他外在的数据进行行为感知，可以识别人体所处的环境等。</p>
<h3 id="行为感知目前存在的挑战"><a href="#行为感知目前存在的挑战" class="headerlink" title="行为感知目前存在的挑战"></a>行为感知目前存在的挑战</h3><p> 行为感知取得了长足的进步，但是仍然有一些问题需要解决：<br> （1）空类数据。<br> 由于行为感知模型只能识别有限种类的行为，连续采集的用户日常生活的数据流仅包含少量与我们感兴趣的行为对应的数据段和大量的无关数据段（空类数据）。那些与行为对应的数据段类似的空类数据很容易干扰模型的学习过程。  </p>
<p> （2）行为的个性化与多样性。<br> 不仅不同用户的相同行为具有多样性，同一个用户的某一种行为由于部分因素（压力、疲劳程度、情感状态、环境因素等）的影响，也会表现出多样性。 </p>
<p> （3）类别不平衡。 ==用户长期的日常生活中仅包含频繁的周期性行为（如：睡觉、工作等）、大量的间歇性行为（如：喝水）和极少的偶发性行为（如：跌倒），因此针对用户的日常行为进行建模面临类别不平衡问题。==</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/行为感知/" data-id="cjfzmj0nx00042wg5s8hjq2ts" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/hello-world/" class="article-date">
  <time datetime="2018-04-14T16:52:17.407Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/hello-world/" data-id="cjfzmj0n300002wg5trmc3jzi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于对extrasenssoryy数据集的整理和反思" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/关于对extrasenssoryy数据集的整理和反思/" class="article-date">
  <time datetime="2018-04-14T16:46:35.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/关于对extrasenssoryy数据集的整理和反思/">关于对extrasenssoryy数据集的整理和反思</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="关于ExtraSensory-数据集的分析过程"><a href="#关于ExtraSensory-数据集的分析过程" class="headerlink" title="关于ExtraSensory 数据集的分析过程"></a>关于ExtraSensory 数据集的分析过程</h2><blockquote>
<p>在这一周的学习当中，我进行对UCSD的传感器数据集进行了分析和学习，我对我学习和尝试的过程，进行复盘</p>
</blockquote>
<p>我们首先先从需要解决的问题入手：  </p>
<ul>
<li>我们需要对数据进行了解和清洗  </li>
<li>清洗完成后我们需要对其做一个分类的问题</li>
</ul>
<h2 id="观察数据"><a href="#观察数据" class="headerlink" title="观察数据"></a>观察数据</h2><p>根据官网的描述，我们得知如下：<br>ExtraSensory 数据集由 UCSD 下 Yonatan Vaizman 和 Katherine Ellis 收集， 由手机 APP –the<br>ExtraSensory App进行收集，收集的信息为手机各类传感器的数据和此时的人体状态等一些数据。<br>该数据集有 60个’csv.gz’文件，文件的命名格式为[UUID].features_label.csv.gz。 UUID为每个用户独有的 ID， 使用 gzip 进行压缩。</p>
<p>我们打开其中一个UUID为 1155FF54-63D3-4AB2-9863-8385D0BD0A13 的单个数据集<br>进行分析，我们可以得知如下：<br><img src="https://ws1.sinaimg.cn/large/005QjmNIgy1fp8qudv71lj30ik0cfwf1.jpg" alt=""></p>
<p>我们对其进行具体的观察，我们得知在该数据集中以timestamp作为主键进行排序，拥有225个feature，和51个label，和一个sourelabel（此不作为label进行学习）</p>
<p>我当时第一个想法是将csv文件读入后，将timestamp、feature、label三部分进行划分，单独取出来  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"># parse_header_of_csv函数将feature和label进行区分归类</span><br><span class="line"># parse_body_of_csv函数将feature和label的具体数据进行分割存储</span><br><span class="line"># read_user_data函数将csv文件读入</span><br><span class="line">def parse_header_of_csv(csv_str):</span><br><span class="line">    headline = csv_str[:csv_str.index(&apos;\n&apos;)]</span><br><span class="line">    column = headline.split(&quot;,&quot;)</span><br><span class="line">    </span><br><span class="line">    # 进行assert测试</span><br><span class="line">    assert column[0] == &apos;timestamp&apos;</span><br><span class="line">    assert column[-1] == &apos;label_source&apos;</span><br><span class="line">    </span><br><span class="line">    # 找到label开始的位置</span><br><span class="line">    for (ci,col) in enumerate(column):</span><br><span class="line">        if col.startswith(&quot;label:&quot;):</span><br><span class="line">            first_start_lind = ci</span><br><span class="line">            break</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    feature_names = column[1:first_start_lind]</span><br><span class="line">    label_names = column[first_start_lind:-1]</span><br><span class="line">    </span><br><span class="line">    ##去除多余无效的字符</span><br><span class="line">    for (li,label) in enumerate(label_names):</span><br><span class="line">        # assert </span><br><span class="line">        assert label.startswith(&quot;label:&quot;)</span><br><span class="line">        label_names[li] = label.replace(&apos;label:&apos;,&quot;&quot;)</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    return (feature_names, label_names)</span><br><span class="line"></span><br><span class="line">def parse_body_of_csv(csv_str,n_feature):</span><br><span class="line"></span><br><span class="line">    full_body = np.loadtxt(StringIO(csv_str),delimiter=&apos;,&apos;,skiprows=1)</span><br><span class="line">    </span><br><span class="line">    # 数据的主键为timestamp</span><br><span class="line">    timestamps = full_body[:,0].astype(int)</span><br><span class="line"></span><br><span class="line">    # 将特征和标签分开,前面的是特征即传感器</span><br><span class="line">    X = full_body[:,1:(n_feature+1)]</span><br><span class="line">    </span><br><span class="line">    #分离出所有label数据</span><br><span class="line">    trinary_labels_mat = full_body[:,(n_feature+1):-1]</span><br><span class="line">    M = np.isnan(trinary_labels_mat)# 将其进行判断有哪些是nan值</span><br><span class="line">    Y = np.where(M,0,trinary_labels_mat)&gt;0.## 进行判断哪里有Nan值则将其转化为0，则保留原来的数值</span><br><span class="line">                                           ##并将其转化为布尔值</span><br><span class="line">    return (X,Y,M,timestamps)</span><br><span class="line"></span><br><span class="line"># 输出feature数据矩阵X，label数据矩阵Y，label的缺失数据分布矩阵M，feature_names,label_names    </span><br><span class="line">def read_user_data(uiud):</span><br><span class="line">    user_data_file = &apos;%s.features_labels.csv.gz&apos;%uuid</span><br><span class="line">    </span><br><span class="line">    with gzip.open(user_data_file,&apos;r&apos;) as fid:</span><br><span class="line">        csv_str = fid.read()</span><br><span class="line">        csv_str = csv_str.decode(encoding = &apos;utf-8&apos;)</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    (feature_names,label_names) = parse_header_of_csv(csv_str)</span><br><span class="line">    n_feature = len(feature_names)</span><br><span class="line">    (X,Y,M,timestamps) = parse_body_of_csv(csv_str, n_feature)</span><br><span class="line">    </span><br><span class="line">    return (X,Y,M,timestamps,feature_names,label_names)</span><br></pre></td></tr></table></figure>
<p>在这段代码中，主要有三个函数<br>def read_user_data(uiud)读入用户数据，并且其中将读取数据的过程再次抽离出两个函数进行抽象。分别是：parse_header_of_csv()、 parse_body_of_csv().</p>
<blockquote>
<p>值得注意的是在这里，我们使用的Python，Python在IO输入的时候和Python2有所不同，我们进行读取之后需要对其进行decode()操作，encoding为utf-8</p>
</blockquote>
<p>parse_header_of_csv(csv_str)函数：由于我们直接将csv文件整个进行输入，所以我们直接将其作为一个大的str进行分析，我们通过判断\n的位置，进行对heading(column)的截取。为了更为严谨，我们在其中插入了assert函数进行判断，截取之后再使用enumerate对column进行从新标号，判断label开始的位置，得到位置之后在依旧使用enumrate对其进行分析，对label标签进行处理，return (feature_names, label_names)</p>
<h3 id="对feature部分进行整理分析"><a href="#对feature部分进行整理分析" class="headerlink" title="对feature部分进行整理分析"></a>对feature部分进行整理分析</h3><p>parse_body_of_csv(csv_str,n_feature)函数：我们使用使用numpy中的loadtxt进行读取，以StringIo进行读取，在将feature和label进行分割。<br>​    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#分离出所有label数据</span><br><span class="line">trinary_labels_mat = full_body[:,(n_feature+1):-1]</span><br><span class="line">M = np.isnan(trinary_labels_mat)# 将其进行判断有哪些是nan值</span><br><span class="line">Y = np.where(M,0,trinary_labels_mat)&gt;0.</span><br><span class="line">##进行判断哪里有Nan值则将其转化为0，则保留原来的数值</span><br><span class="line">##并将其转化为布尔值</span><br></pre></td></tr></table></figure>
<p>由上我们得到状态存在矩阵M,同时使用where函数对其进行从新置换。</p>
<h2 id="return-X-Y-M-timestamps"><a href="#return-X-Y-M-timestamps" class="headerlink" title="return (X,Y,M,timestamps)"></a>return (X,Y,M,timestamps)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 观察feature数据中每列的nan值分布情况</span><br><span class="line">X_df.count()              </span><br><span class="line">X_df.shape[0] - X_df.count()</span><br></pre></td></tr></table></figure>
<p>我们观察feature中每一列feature中nan的分布情况<br><img src="https://ws1.sinaimg.cn/large/005QjmNIgy1fp8r05jf3lj30aq0c2glu.jpg" alt=""></p>
<blockquote>
<p>我们可以发现还是有部分的feature列整个feature是缺失的<br>对于这种现象我们对其进行处理原则为若某个feature列中feature的个数缺失值占比超过该列的50%则将其进行删除</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">X_df.columns = feature_names</span><br><span class="line">Y_df.columns = label_names##为他们增加具体的列名</span><br><span class="line"></span><br><span class="line">cleaning_data = pd.concat([X_df,Y_df], axis=1)</span><br><span class="line"></span><br><span class="line">## 观察Nan值分布之后若nan值超过百分之50就把这列删掉</span><br><span class="line">def drop_col(df, col_name, cutoff=0.5):</span><br><span class="line">    n = len(df)</span><br><span class="line">    cnt = df[col_name].count()</span><br><span class="line">    if (float(cnt) / n) &lt; cutoff:</span><br><span class="line">        df.drop(col_name, axis=1, inplace=True)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">cleaning_data_heading = list(np.array(cleaning_data.columns))</span><br><span class="line">for name in cleaning_data_heading:</span><br><span class="line">    drop_col(cleaning_data, name, cutoff=0.5)</span><br></pre></td></tr></table></figure>
<h3 id="对label部分进行处理和分析"><a href="#对label部分进行处理和分析" class="headerlink" title="对label部分进行处理和分析"></a>对label部分进行处理和分析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># 根据论文中的要求将某些label名称进行进一步修缮</span><br><span class="line">def get_label_pretty_name(label):</span><br><span class="line">    if label == &apos;FIX_walking&apos;:</span><br><span class="line">        return &apos;Walking&apos;</span><br><span class="line">    if label == &apos;FIX_running&apos;:</span><br><span class="line">        return &apos;Running&apos;</span><br><span class="line">    if label == &apos;LOC_main_workplace&apos;:</span><br><span class="line">        return &apos;At main workplace&apos;</span><br><span class="line">    if label == &apos;OR_indoors&apos;:</span><br><span class="line">        return &apos;Indoors&apos;</span><br><span class="line">    if label == &apos;OR_outside&apos;:</span><br><span class="line">        return &apos;Outside&apos;</span><br><span class="line">    if label == &apos;LOC_home&apos;:</span><br><span class="line">        return &apos;At home&apos;</span><br><span class="line">    if label == &apos;FIX_restaurant&apos;:</span><br><span class="line">        return &apos;At a restaurant&apos;</span><br><span class="line">    if label == &apos;OR_exercise&apos;:</span><br><span class="line">        return &apos;Exercise&apos;</span><br><span class="line">    if label == &apos;LOC_beach&apos;:</span><br><span class="line">        return &apos;At the beach&apos;</span><br><span class="line">    if label == &apos;OR_standing&apos;:</span><br><span class="line">        return &apos;Standing&apos;</span><br><span class="line">    if label == &apos;WATCHING_TV&apos;:</span><br><span class="line">        return &apos;Watching TV&apos;</span><br><span class="line">    </span><br><span class="line">    if label.endswith(&apos;_&apos;):</span><br><span class="line">        label = label[:-1] + &apos;)&apos;</span><br><span class="line">        pass</span><br><span class="line">    </span><br><span class="line">    label = label.replace(&apos;__&apos;,&apos; (&apos;).replace(&apos;_&apos;,&apos; &apos;)</span><br><span class="line">    label = label[0] + label[1:].lower()</span><br><span class="line">    label = label.replace(&apos;i m&apos;,&apos;I\&apos;m&apos;)</span><br><span class="line">    return label</span><br></pre></td></tr></table></figure>
<p>根据数据集说明，该数据集以timestamp进行排序，每个例子以60s进行分割，即1分钟一次，我们进行统计每个label状态下所占用时间的统计情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 统计每个label上用户占用的时间</span><br><span class="line">n_examples_per_label = np.sum(Y, axis=0)</span><br><span class="line">labels_and_counts = zip(label_names,n_examples_per_label)</span><br><span class="line"></span><br><span class="line">label_names_fix = []</span><br><span class="line">label_names_clean =[]</span><br><span class="line">for (label,count) in labels_and_counts:</span><br><span class="line">    label_names_fix.append(get_label_pretty_name(label))</span><br><span class="line">    print (&quot;%s - %d minutes&quot; % (get_label_pretty_name(label),count))</span><br><span class="line">    if count &gt;=10:</span><br><span class="line">        label_names_clean.append(label)</span><br><span class="line">    ##label = get_label_pretty_name(label)</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在这里我们也进行处理，只有超过10min的保留在label_names_clean<br>中。</p>
</blockquote>
<p>根据论文，我们将feature还原回sensor（包括一些自己定的分类）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"># 将feature进行分类还原成sensor</span><br><span class="line">def get_sensor_names_from_features(feature_names):</span><br><span class="line">    feat_sensor_names = np.array([None for feat in feature_names]);</span><br><span class="line">    for (fi,feat) in enumerate(feature_names):</span><br><span class="line">        if feat.startswith(&apos;raw_acc&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Acc&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;proc_gyro&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Gyro&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;raw_magnet&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Magnet&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;watch_acceleration&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;WAcc&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;watch_heading&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Compass&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;location&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Loc&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;location_quick_features&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Loc&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;audio_naive&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;Aud&apos;;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;audio_properties&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;AP&apos;;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;discrete&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;PS&apos;</span><br><span class="line">            pass</span><br><span class="line">        elif feat.startswith(&apos;lf_measurements&apos;):</span><br><span class="line">            feat_sensor_names[fi] = &apos;LF&apos;</span><br><span class="line">            pass</span><br><span class="line">        else:</span><br><span class="line">            raise ValueError(&quot;!!! Unsupported feature name: %s&quot; % feat)</span><br><span class="line"></span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    return feat_sensor_names</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 展示</span><br><span class="line">for (fi,feature) in enumerate(feature_names):</span><br><span class="line">    print(&quot;%4d) %s %s&quot; % (fi,feat_sensor_names[fi].ljust(10),feature))## ljust指的是对于右对齐</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>
<p>我们进行分析展示如下  </p>
<p><img src="https://ws1.sinaimg.cn/large/005QjmNIgy1fp8s31fyp5j30gm07raat.jpg" alt=""></p>
<h2 id="进行训练"><a href="#进行训练" class="headerlink" title="进行训练"></a>进行训练</h2><p>在这次的学习当中我是用的是sklearn进行对数据的进行训练<br>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">    import sklearn.linear_model</span><br><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line">from sklearn import cross_validation</span><br><span class="line"># 进行选择sensor作为训练数据</span><br><span class="line">def project_features_to_selected_sensors(X,feat_sensor_names,sensors_to_use):</span><br><span class="line">    use_feature = np.zeros(len(feat_sensor_names),dtype=bool)# 制造出和feature那么长度相等的bool序列</span><br><span class="line">    for sensor in sensors_to_use:</span><br><span class="line">        is_from_sensor = (feat_sensor_names == sensor)#判断是否</span><br><span class="line">        use_feature = np.logical_or(use_feature,is_from_sensor)## 选择出</span><br><span class="line">        pass</span><br><span class="line">                          </span><br><span class="line">    X = X[:,use_feature]</span><br><span class="line">    return X</span><br><span class="line"></span><br><span class="line"># 进行数据的归一化</span><br><span class="line">def estimate_standardization_params(X_train):</span><br><span class="line">    mean_vec = np.nanmean(X_train,axis=0)</span><br><span class="line">    std_vec = np.nanstd(X_train,axis=0)</span><br><span class="line">    return (mean_vec,std_vec)</span><br><span class="line"></span><br><span class="line">def standardize_features(X,mean_vec,std_vec):</span><br><span class="line">    X_centralized = X - mean_vec.reshape((1,-1))</span><br><span class="line">    normalizers = np.where(std_vec &gt; 0., std_vec, 1.).reshape((1,-1))</span><br><span class="line">    X_standard = X_centralized / normalizers</span><br><span class="line">    return X_standard</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def train_model(X_train,Y_train,M_train,feat_sensor_names,label_names,sensors_to_use,target_label):</span><br><span class="line">    X_train = project_features_to_selected_sensors(X_train,feat_sensor_names,sensors_to_use)</span><br><span class="line">    print(&quot;== Projected the features to %d features from the sensors: %s&quot; % (X_train.shape[1],&apos;, &apos;.join(sensors_to_use)))</span><br><span class="line"></span><br><span class="line">    ## 将其特征进行尽量的标准化</span><br><span class="line">    (mean_vec,std_vec) = estimate_standardization_params(X_train)</span><br><span class="line">    X_train = standardize_features(X_train,mean_vec,std_vec)</span><br><span class="line">    </span><br><span class="line">    #选择需要进行测试的label</span><br><span class="line">    label_ind = label_names.index(target_label)</span><br><span class="line">    y = Y_train[:,label_ind]</span><br><span class="line">    missing_label = M_train[:,label_ind]</span><br><span class="line">    existing_label = np.logical_not(missing_label)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    # 因为有些label不存在例子，所以我们选择是只选择拥有该label的例子</span><br><span class="line">    X_train = X_train[existing_label,:]</span><br><span class="line">    y = y[existing_label]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #为了将其进行更好的分析，我们将nan值进行直接赋值为0</span><br><span class="line">    X_train[np.isnan(X_train)] = 0.</span><br><span class="line">    X_train,X_test,y_train,y_test = cross_validation.train_test_split(X_train,y,test_size=0.3,random_state=4)</span><br><span class="line">    </span><br><span class="line">    print(&quot;== Training with %d examples. For label &apos;%s&apos; we have %d positive and %d negative examples.&quot; % \</span><br><span class="line">          (len(y_train),get_label_pretty_name(target_label),sum(y_train),sum(np.logical_not(y_train))) )</span><br><span class="line">    </span><br><span class="line">    # 进行训练 </span><br><span class="line">    lr_model = sklearn.linear_model.LogisticRegression(class_weight=&apos;balanced&apos;)</span><br><span class="line">    lr_model.fit(X_train,y_train)</span><br><span class="line">    </span><br><span class="line">    # 进行声明</span><br><span class="line">    </span><br><span class="line">    model = &#123;\</span><br><span class="line">            &apos;sensors_to_use&apos;:sensors_to_use,\</span><br><span class="line">            &apos;target_label&apos;:target_label,\</span><br><span class="line">            &apos;mean_vec&apos;:mean_vec,\</span><br><span class="line">            &apos;std_vec&apos;:std_vec,\</span><br><span class="line">            &apos;lr_model&apos;:lr_model\</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<h3 id="对数据进行归一化"><a href="#对数据进行归一化" class="headerlink" title="对数据进行归一化"></a>对数据进行归一化</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 进行数据的归一化</span><br><span class="line">def estimate_standardization_params(X_train):</span><br><span class="line">    mean_vec = np.nanmean(X_train,axis=0)</span><br><span class="line">    std_vec = np.nanstd(X_train,axis=0)</span><br><span class="line">    return (mean_vec,std_vec)</span><br><span class="line"></span><br><span class="line">def standardize_features(X,mean_vec,std_vec):</span><br><span class="line">    X_centralized = X - mean_vec.reshape((1,-1))</span><br><span class="line">    normalizers = np.where(std_vec &gt; 0., std_vec, 1.).reshape((1,-1))</span><br><span class="line">    X_standard = X_centralized / normalizers</span><br><span class="line">    return X_standard</span><br></pre></td></tr></table></figure>
<p>为了更好的进行学习，我们对数据进行归一化<br>归一化流程如下:</p>
<ul>
<li>计算出每一行例子的平均值</li>
<li>计算出每一行例子的标准差</li>
<li>将X的每一行减去平均值得到X_centralized</li>
<li>对std进行判断，若&gt;0，则将其保留否则转化为1得到normalizers</li>
<li>将X_centralized/normalizers 得到X_standard</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">def train_model(X_train,Y_train,M_train,feat_sensor_names,label_names,sensors_to_use,target_label):</span><br><span class="line">    X_train = project_features_to_selected_sensors(X_train,feat_sensor_names,sensors_to_use)</span><br><span class="line">    print(&quot;== Projected the features to %d features from the sensors: %s&quot; % (X_train.shape[1],&apos;, &apos;.join(sensors_to_use)))</span><br><span class="line"></span><br><span class="line">    ## 将其特征进行尽量的标准化</span><br><span class="line">    (mean_vec,std_vec) = estimate_standardization_params(X_train)</span><br><span class="line">    X_train = standardize_features(X_train,mean_vec,std_vec)</span><br><span class="line">    </span><br><span class="line">    #选择需要进行测试的label</span><br><span class="line">    label_ind = label_names.index(target_label)</span><br><span class="line">    y = Y_train[:,label_ind]</span><br><span class="line">    missing_label = M_train[:,label_ind]</span><br><span class="line">    existing_label = np.logical_not(missing_label)</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">    # 因为有些label不存在例子，所以我们选择是只选择拥有该label的例子</span><br><span class="line">    X_train = X_train[existing_label,:]</span><br><span class="line">    y = y[existing_label]</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    #为了将其进行更好的分析，我们将nan值进行直接赋值为0</span><br><span class="line">    X_train[np.isnan(X_train)] = 0.</span><br><span class="line">    X_train,X_test,y_train,y_test = cross_validation.train_test_split(X_train,y,test_size=0.3,random_state=4)</span><br><span class="line">    </span><br><span class="line">    print(&quot;== Training with %d examples. For label &apos;%s&apos; we have %d positive and %d negative examples.&quot; % \</span><br><span class="line">          (len(y_train),get_label_pretty_name(target_label),sum(y_train),sum(np.logical_not(y_train))) )</span><br><span class="line">    </span><br><span class="line">    # 进行训练 </span><br><span class="line">    lr_model = sklearn.linear_model.LogisticRegression(class_weight=&apos;balanced&apos;)</span><br><span class="line">    lr_model.fit(X_train,y_train)</span><br><span class="line">    </span><br><span class="line">    # 进行声明</span><br><span class="line">    </span><br><span class="line">    model = &#123;\</span><br><span class="line">            &apos;sensors_to_use&apos;:sensors_to_use,\</span><br><span class="line">            &apos;target_label&apos;:target_label,\</span><br><span class="line">            &apos;mean_vec&apos;:mean_vec,\</span><br><span class="line">            &apos;std_vec&apos;:std_vec,\</span><br><span class="line">            &apos;lr_model&apos;:lr_model\</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<p>我们对函数进行分析</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 进行选择sensor作为训练数据</span><br><span class="line">def project_features_to_selected_sensors(X,feat_sensor_names,sensors_to_use):</span><br><span class="line">    use_feature = np.zeros(len(feat_sensor_names),dtype=bool)# 制造出和feature那么长度相等的bool序列</span><br><span class="line">    for sensor in sensors_to_use:</span><br><span class="line">        is_from_sensor = (feat_sensor_names == sensor)#判断是否</span><br><span class="line">        use_feature = np.logical_or(use_feature,is_from_sensor)## 选择出</span><br><span class="line">        pass</span><br><span class="line">                          </span><br><span class="line">    X = X[:,use_feature]</span><br><span class="line">    return X</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个函数最有意思了</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X_train,X_test,y_train,y_test = cross_validation.train_test_split(X_train,y,test_size=0.3,random_state=4)</span><br></pre></td></tr></table></figure>
<p>我们使用sklearn的交叉验证进行分割数据集，自己的注意的是这里random_state相同的时候分割出来的数据集是一样的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">model = &#123;\</span><br><span class="line">            &apos;sensors_to_use&apos;:sensors_to_use,\</span><br><span class="line">            &apos;target_label&apos;:target_label,\</span><br><span class="line">            &apos;mean_vec&apos;:mean_vec,\</span><br><span class="line">            &apos;std_vec&apos;:std_vec,\</span><br><span class="line">            &apos;lr_model&apos;:lr_model\</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">    return model</span><br></pre></td></tr></table></figure>
<p>当返回的参数过多的时候做成字典会比较好</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">def test_model(X_test,Y_test,M_test,timestamps,feat_sensor_names,label_names,model):</span><br><span class="line">    </span><br><span class="line">    X_test = project_features_to_selected_sensors(X_test,feat_sensor_names,model[&apos;sensors_to_use&apos;])</span><br><span class="line">    print(&quot;== Projected the features to %d features from the sensors: %s&quot; % (X_test.shape[1],&apos;, &apos;.join(model[&apos;sensors_to_use&apos;])));</span><br><span class="line"></span><br><span class="line">    # 标准化的方式来标准化这些数据</span><br><span class="line">    X_test = standardize_features(X_test,model[&apos;mean_vec&apos;],model[&apos;std_vec&apos;])</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    label_ind = label_names.index(model[&apos;target_label&apos;])</span><br><span class="line">    y = Y_test[:,label_ind]</span><br><span class="line">    missing_label = M_test[:,label_ind]</span><br><span class="line">    existing_label = np.logical_not(missing_label)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    X_test = X_test[existing_label,:]</span><br><span class="line">    y = y[existing_label]</span><br><span class="line">    timestamps = timestamps[existing_label]</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    X_test[np.isnan(X_test)] = 0.</span><br><span class="line">    X_train,X_test,y_train,y_test = cross_validation.train_test_split(X_train,y,test_size=0.3,random_state=4)</span><br><span class="line">    print(&quot;== Training with %d examples. For label &apos;%s&apos; we have %d positive and %d negative examples.&quot; % \</span><br><span class="line">          (len(y_train),get_label_pretty_name(target_label),sum(y_train),sum(np.logical_not(y_train))) )</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    # 进行预测</span><br><span class="line">    y_pred = model[&apos;lr_model&apos;].predict(X_test)</span><br><span class="line">    </span><br><span class="line">    # Naive accuracy (correct classification rate):</span><br><span class="line">    accuracy = np.mean(y_pred == y_test)</span><br><span class="line">    </span><br><span class="line">    # （学习自统计学习方法） TP：正对正 FN:正对负 FP:负对正 TN:负对负</span><br><span class="line">    #  TP:正确的肯定数目</span><br><span class="line">    #  FN:漏报，没有找到正确匹配的数目</span><br><span class="line">    #  FP:误报，没有的匹配不正确</span><br><span class="line">    #  TN:正确拒绝的非匹配数目</span><br><span class="line">    tp = np.sum(np.logical_and(y_pred,y_test))</span><br><span class="line">    tn = np.sum(np.logical_and(np.logical_not(y_pred),np.logical_not(y_test)))</span><br><span class="line">    fp = np.sum(np.logical_and(y_pred,np.logical_not(y_test)))</span><br><span class="line">    fn = np.sum(np.logical_and(np.logical_not(y_pred),y_test))</span><br><span class="line">    # 召回率</span><br><span class="line">    # Sensitivity (=recall=true positive rate) and Specificity (=true negative rate):</span><br><span class="line">    sensitivity = float(tp) / (tp+fn)# 召回率</span><br><span class="line">    specificity = float(tn) / (tn+fp)# </span><br><span class="line">    </span><br><span class="line">    balanced_accuracy = (sensitivity + specificity) / 2.</span><br><span class="line">    </span><br><span class="line">    precision = float(tp) / (tp+fp) # 精确率</span><br><span class="line">    F1 = 2*float(tp)/(2*tp+fp+fn)# F1值</span><br><span class="line">    </span><br><span class="line">    print(&quot;-&quot;*10);</span><br><span class="line">    print(&apos;Accuracy:         %.2f&apos; % accuracy)</span><br><span class="line">    print(&apos;Sensitivity (TPR): %.2f&apos; % sensitivity)</span><br><span class="line">    print(&apos;Specificity (TNR): %.2f&apos; % specificity)</span><br><span class="line">    print(&apos;Balanced accuracy: %.2f&apos; % balanced_accuracy)</span><br><span class="line">    print(&apos;Precision:       %.2f&apos; % precision)</span><br><span class="line">    print(&apos;F1:              %.2f&apos; % F1)</span><br><span class="line">    print(&quot;-&quot;*10)</span><br><span class="line">    </span><br><span class="line">    model2 = &#123;&apos;accuracy&apos;:accuracy,&apos;sensitivity (TPR)&apos;:sensitivity,&apos;specificity (TNR)&apos;:specificity,&apos;balanced accuracy&apos;:balanced_accuracy,&apos;precision&apos;:precision,&apos;F1&apos;:F1&#125;</span><br><span class="line">    return model2</span><br></pre></td></tr></table></figure>
<p>验证当中我们使用如上的参数进行验证</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">sensors_to_use = [&apos;Acc&apos;,&apos;Gyro&apos;,&apos;Magnet&apos;]</span><br><span class="line">Accuracy = []</span><br><span class="line">Sensitivity = []</span><br><span class="line">Specificity = []</span><br><span class="line">Balanced_accuracy = []</span><br><span class="line">Precision = []</span><br><span class="line">F1 = []</span><br><span class="line"></span><br><span class="line">for label in label_names_clean:</span><br><span class="line">    target_label = label# 原始标签是FIX_walking</span><br><span class="line">    model = train_model(X,Y,M,feat_sensor_names,label_names,sensors_to_use,target_label)</span><br><span class="line">    model2 = test_model(X,Y,M,timestamps,feat_sensor_names,label_names,model)</span><br><span class="line">    Accuracy.append(model2[&apos;accuracy&apos;])</span><br><span class="line">    Sensitivity.append(model2[&apos;sensitivity (TPR)&apos;])</span><br><span class="line">    Specificity.append(model2[&apos;specificity (TNR)&apos;])</span><br><span class="line">    Balanced_accuracy.append(model2[&apos;balanced accuracy&apos;])</span><br><span class="line">    Precision.append(model2[&apos;precision&apos;])</span><br><span class="line">    F1.append(model2[&apos;F1&apos;])</span><br></pre></td></tr></table></figure>
<p>我们将所有label都跑一边</p>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>由于这个数据集正负标签数量并不平衡，所以单看某些指标是不合适的，下一步我要将每个label的ROC曲线进行绘制</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/关于对extrasenssoryy数据集的整理和反思/" data-id="cjfzmj0nk00022wg5b15k7tt4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HAR/">HAR</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-人体感知" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/04/15/人体感知/" class="article-date">
  <time datetime="2018-04-14T16:37:42.000Z" itemprop="datePublished">2018-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/04/15/人体感知/">人体行为感知概要</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是行为感知"><a href="#什么是行为感知" class="headerlink" title="什么是行为感知"></a>什么是行为感知</h3><p> 行为感知就是利用传感器捕获人体特定行为的信号，根据信号来对人的行为作出判断，并根据行为给出相应措施的一个研究方向。从疾病到日常生活，从心理状态到情绪，都可以由特定的行为反映出来。而特定的行为可以由特定的传感器进行捕捉。因此，进行行为感知是有效的。比如，一个可以完整进行行为感知的应用，可以针对学生群体，除运动、社交和睡眠外，还进行了饮食规律、学习表现、个人情绪、精神压力状况等更全面的健康监测研究，这对人的生活水平的提高是有着积极意义的。 行为感知涉及到机器学习、数据挖掘、信号处理等多个研究领域，属于多学科交叉性研究。基本的行为识别过程是，从传感器中获取行为数据，对这些数据进行预处理，提取有意义的特征，然后用机器学习模型进行分类和预测。</p>
<h3 id="行为感知的类别"><a href="#行为感知的类别" class="headerlink" title="行为感知的类别"></a>行为感知的类别</h3><p> 从使用的传感器上来划分，行为识别大致可以分为以下几类：</p>
<p> （1）基于视频图像的行为感知。捕捉人体在运动时的视频和图像，通过对这些资料的分析，进行行为识别。</p>
<p> （2）基于可穿戴传感器的行为感知。这一类是目前最火的研究领域，因为大多数的行为都可以由加速度、陀螺仪等低成本传感器进行捕获。现有的绝大多数智能手机、智能手表、手环等，基本都集成了加速度计、陀螺仪。因此，利用这些设备进行行为感知非常方便，结果也很好。 </p>
<p> （3）基于环境与物体传感器的行为感知。利用RFID数据、声音数据、环境温度、光照等其他外在的数据进行行为感知，可以识别人体所处的环境等。</p>
<h3 id="行为感知目前存在的挑战"><a href="#行为感知目前存在的挑战" class="headerlink" title="行为感知目前存在的挑战"></a>行为感知目前存在的挑战</h3><p> 行为感知取得了长足的进步，但是仍然有一些问题需要解决：<br> （1）空类数据。<br> 由于行为感知模型只能识别有限种类的行为，连续采集的用户日常生活的数据流仅包含少量与我们感兴趣的行为对应的数据段和大量的无关数据段（空类数据）。那些与行为对应的数据段类似的空类数据很容易干扰模型的学习过程。  </p>
<p> （2）行为的个性化与多样性。<br> 不仅不同用户的相同行为具有多样性，同一个用户的某一种行为由于部分因素（压力、疲劳程度、情感状态、环境因素等）的影响，也会表现出多样性。 </p>
<p> （3）类别不平衡。用户长期的日常生活中仅包含频繁的周期性行为（如：睡觉、工作等）、大量的间歇性行为（如：喝水）和极少的偶发性行为（如：跌倒），因此针对用户的日常行为进行建模面临类别不平衡问题.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/04/15/人体感知/" data-id="cjfzmj0nb00012wg5nrnyeijs" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/HAR/">HAR</a></li></ul>

    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/HAR/">HAR</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/HAR/" style="font-size: 10px;">HAR</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/04/15/行为感知/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/04/15/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2018/04/15/关于对extrasenssoryy数据集的整理和反思/">关于对extrasenssoryy数据集的整理和反思</a>
          </li>
        
          <li>
            <a href="/2018/04/15/人体感知/">人体行为感知概要</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>